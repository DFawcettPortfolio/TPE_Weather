package com.example.tpeweatherroller

import android.content.Context
import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.pdf.PdfDocument
import android.os.Bundle
import android.os.Environment
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.example.tpeweatherroller.ui.theme.TPEWeatherRollerTheme
import kotlin.random.Random
import java.io.File
import java.io.FileOutputStream
import android.content.ContentValues
import android.os.Build
import android.provider.MediaStore
import java.io.OutputStream
import android.widget.Toast


// Weather strings
val BlecksShade = "Shadows stretch unnaturally. The first short rest the party takes each day may be completed in 5 minutes."
val AzrahsWinds = "A gentle tailwind urges travelers onward. All creatures gain +5 feet to base movement speed."
val KalisTears = "Steady rainfall blesses the earth. The land becomes dotted with clean water sources, sufficient for safe drinking."
val MaeoriasClouds = "The sky is overcast with peaceful gray. On the first Wisdom saving throw each day, each creature gains advantage."
val HushsEmptiness = "A cloudless silence. Bright sun counts as bright light; spotting illusions is at disadvantage due to the intense glare and stillness."
val IAsFog = "A thin mist obscures all. Vision beyond 30 feet is lightly obscured. Perception checks relying on sight are at disadvantage past that."
val SuthisScorcher = "A relentless desert sun. Unshaded creatures take 1d6 fire damage per hour of travel (enhanced: 1d12 in desert regions)."
val UnisRot = "Decay clings to wounds. If a creature is bloodied, it takes 1d4 necrotic damage at the start of its turn."
val DaunthurgesLongDay = "Time stretches painfully. Gain 1 level of exhaustion per day, max 1 from this effect."

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            TPEWeatherRollerTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = Color(0xFFA56BC0)
                ) {
                    Greeting()
                }
            }
        }
    }
}

@Composable
fun Greeting(modifier: Modifier = Modifier) {
    var rollResult by remember { mutableStateOf("") }
    var WeatherDataRange by remember { mutableStateOf<String?>(null) }
    val scrollState = rememberScrollState()
    val context = LocalContext.current
    var showDurationDialog by remember { mutableStateOf(false) }
    var inputDay by remember { mutableStateOf("") }
    var inputMonth by remember { mutableStateOf("") }
    var inputYear by remember { mutableStateOf("") }
    var inputDuration by remember { mutableStateOf("") }


    Column(
        modifier = modifier
            .padding(16.dp)
            .fillMaxSize()
    ) {
        Spacer(modifier = Modifier.height(32.dp))

        Text(
            text = "Weather",
            fontSize = 28.sp,
            modifier = Modifier.padding(bottom = 16.dp)
        )

        Column(
            modifier = Modifier
                .weight(1f)
                .verticalScroll(scrollState)
        ) {
            Text(text = rollResult, fontSize = 20.sp)
        }

        Spacer(modifier = Modifier.height(24.dp))

        Button(
            onClick = {
                rollResult = rollIt().first
                WeatherDataRange = null // Clear yearly data when rolling single weather
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Roll for weather", fontSize = 26.sp)
        }

        Spacer(modifier = Modifier.height(16.dp))

        Button(
            onClick = {
                showDurationDialog = true
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Roll for custom duration", fontSize = 20.sp)
        }



        if (WeatherDataRange != null) {
            Spacer(modifier = Modifier.height(16.dp))
            Button(
                onClick = {
                    WeatherDataRange?.let { data ->
                        exportToPdf(context, data)
                    }
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Export to PDF", fontSize = 20.sp)
            }
        }

        Spacer(modifier = Modifier.height(60.dp))
    }

    if (showDurationDialog) {
        AlertDialog(
            onDismissRequest = { showDurationDialog = false },
            title = { Text("Custom Weather Simulation") },
            text = {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {

                    OutlinedTextField(
                        value = inputMonth,
                        onValueChange = { inputMonth = it },
                        label = { Text("Start Month (1–12)") },
                        singleLine = true
                    )
                    OutlinedTextField(
                        value = inputDay,
                        onValueChange = { inputDay = it },
                        label = { Text("Start Day (1–30)") },
                        singleLine = true
                    )
                    OutlinedTextField(
                        value = inputYear,
                        onValueChange = { inputYear = it },
                        label = { Text("Start Year") },
                        singleLine = true
                    )
                    OutlinedTextField(
                        value = inputDuration,
                        onValueChange = { inputDuration = it },
                        label = { Text("Duration (in days)") },
                        singleLine = true
                    )
                }
            },
            confirmButton = {
                TextButton(onClick = {
                    val day = inputDay.toIntOrNull()
                    val month = inputMonth.toIntOrNull()
                    val year = inputYear.toIntOrNull()
                    val duration = inputDuration.toIntOrNull()

                    if (
                        day != null && day in 1..30 &&
                        month != null && month in 1..12 &&
                        year != null &&
                        duration != null && duration > 0
                    ) {
                        val startDayOfYear = (month - 1) * 30 + day
                        val result = WeatherDuration(
                            startDayOfYear = startDayOfYear,
                            durationInDays = duration,
                            startYear = year
                        )
                        rollResult = result
                        WeatherDataRange = result
                        showDurationDialog = false
                    }
                }) {
                    Text("Roll")
                }
            },
            dismissButton = {
                TextButton(onClick = { showDurationDialog = false }) {
                    Text("Cancel")
                }
            }
        )
    }


}


fun rollIt(): Pair<String, Int> {
    val weatherRoll = Random.nextInt(1, 11)

    val weatherMap = mapOf(
        1 to Triple(BlecksShade, "Bleck's Shade", 4),
        2 to Triple(AzrahsWinds, "Azrah's Winds", 6),
        3 to Triple(KalisTears, "Kali's Tears", 8),
        4 to Triple(MaeoriasClouds, "Maeoria's Clouds", 10),
        5 to Triple(HushsEmptiness, "Hush's Emptiness", 12),
        6 to Triple(IAsFog, "IA's Fog", 12),
        7 to Triple(SuthisScorcher, "Suthis' Scorcher", 10),
        8 to Triple(UnisRot, "Uni's Rot", 8),
        9 to Triple(DaunthurgesLongDay, "Daunthurge's Long Day", 6)
    )

    return if (weatherRoll == 10) {
        val options = (1..9).shuffled()
        val roll1 = options[0]
        val roll2 = options[1]

        val (effect1, title1, _) = weatherMap[roll1]!!
        val (effect2, title2, _) = weatherMap[roll2]!!

        val durationRoll = Random.nextInt(1, 5)

        Pair("Nyx's Game: $title1 & $title2\n\n$effect1\n   ~and~ \n$effect2\n\nDuration: $durationRoll days", durationRoll)
    } else {
        val (effect, title, durationDie) = weatherMap[weatherRoll] ?: Triple("Unknown weather effect", "Unknown", 0)
        val durationRoll = Random.nextInt(1, durationDie + 1)
        Pair("$title:\n$effect\n\nDuration: $durationRoll days", durationRoll)
    }
}

fun WeatherDuration(startDayOfYear: Int, durationInDays: Int, startYear: Int): String {
    val log = StringBuilder()
    var totalDays = 0

    while (totalDays < durationInDays) {
        val (result, duration) = rollIt()

        val currentStartDayOfEra = startDayOfYear + totalDays
        val currentNaturalEndDay = currentStartDayOfEra + duration - 1
        val currentClippedEndDay = (currentStartDayOfEra + duration - 1).coerceAtMost(startDayOfYear + durationInDays - 1)

        // Start date
        val startYearOffset = (currentStartDayOfEra - 1) / 360
        val startDayOfYear = (currentStartDayOfEra - 1) % 360 + 1
        val startMonth = (startDayOfYear - 1) / 30 + 1
        val startDay = (startDayOfYear - 1) % 30 + 1
        val displayStartYear = startYear + startYearOffset

        // Clipped end date for range display
        val clippedEndYearOffset = (currentClippedEndDay - 1) / 360
        val clippedEndDayOfYear = (currentClippedEndDay - 1) % 360 + 1
        val clippedEndMonth = (clippedEndDayOfYear - 1) / 30 + 1
        val clippedEndDay = (clippedEndDayOfYear - 1) % 30 + 1
        val displayClippedEndYear = startYear + clippedEndYearOffset

        val dateRange = if (currentStartDayOfEra == currentClippedEndDay) {
            "$startMonth/$startDay/$displayStartYear"
        } else {
            "$startMonth/$startDay/$displayStartYear - $clippedEndMonth/$clippedEndDay/$displayClippedEndYear"
        }

        log.append("$dateRange\n$result")

        // Check if this is the last weather entry (range would end during or right after this effect)
        if (totalDays + duration >= durationInDays) {
            val naturalEndYearOffset = (currentNaturalEndDay - 1) / 360
            val naturalEndDayOfYear = (currentNaturalEndDay - 1) % 360 + 1
            val naturalEndMonth = (naturalEndDayOfYear - 1) / 30 + 1
            val naturalEndDay = (naturalEndDayOfYear - 1) % 30 + 1
            val naturalEndYear = startYear + naturalEndYearOffset

            log.append("\n(Ends $naturalEndMonth/$naturalEndDay/$naturalEndYear)")
        }

        log.append("\n\n")
        totalDays += duration
    }

    return log.toString()
}



fun exportToPdf(context: Context, content: String, filename: String = "weather.pdf") {
    try {
        val document = PdfDocument()
        val paint = Paint().apply {
            textSize = 12f
            isAntiAlias = true
        }

        val pageWidth = 595
        val pageHeight = 842
        val margin = 40f
        val lineHeight = 20f
        val usableWidth = pageWidth - 2 * margin
        val maxLinesPerPage = ((pageHeight - 2 * margin) / lineHeight).toInt()

        // Function to wrap text by words
        fun wrapLine(line: String): List<String> {
            val words = line.split(" ")
            val wrapped = mutableListOf<String>()
            var currentLine = ""

            for (word in words) {
                val testLine = if (currentLine.isEmpty()) word else "$currentLine $word"
                if (paint.measureText(testLine) <= usableWidth) {
                    currentLine = testLine
                } else {
                    if (currentLine.isNotEmpty()) {
                        wrapped.add(currentLine)
                    }
                    currentLine = word
                }
            }

            if (currentLine.isNotEmpty()) {
                wrapped.add(currentLine)
            }

            return wrapped
        }

        // Wrap all content lines
        val wrappedLines = content
            .split("\n")
            .flatMap { wrapLine(it) }

        var currentLineIndex = 0
        var pageNum = 1

        while (currentLineIndex < wrappedLines.size) {
            val pageInfo = PdfDocument.PageInfo.Builder(pageWidth, pageHeight, pageNum).create()
            val page = document.startPage(pageInfo)
            val canvas = page.canvas

            var y = margin
            for (i in 0 until maxLinesPerPage) {
                if (currentLineIndex >= wrappedLines.size) break
                canvas.drawText(wrappedLines[currentLineIndex], margin, y, paint)
                y += lineHeight
                currentLineIndex++
            }

            document.finishPage(page)
            pageNum++
        }

        val resolver = context.contentResolver
        val contentValues = ContentValues().apply {
            put(MediaStore.Downloads.DISPLAY_NAME, filename)
            put(MediaStore.Downloads.MIME_TYPE, "application/pdf")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.Downloads.IS_PENDING, 1)
            }
        }

        val uri = resolver.insert(MediaStore.Downloads.EXTERNAL_CONTENT_URI, contentValues)
        if (uri != null) {
            resolver.openOutputStream(uri).use { outputStream ->
                document.writeTo(outputStream!!)
            }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                contentValues.clear()
                contentValues.put(MediaStore.Downloads.IS_PENDING, 0)
                resolver.update(uri, contentValues, null, null)
            }

            Toast.makeText(context, "Export successful!", Toast.LENGTH_SHORT).show()
        }

        document.close()
    } catch (e: Exception) {
        e.printStackTrace()
    }
}


@Preview(showBackground = true)
@Composable
fun GreetingPreview() {
    TPEWeatherRollerTheme {
        Greeting()
    }
}